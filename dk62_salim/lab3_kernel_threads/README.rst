Звіт з виконання лабораторної роботи №3  
=======================================

1. Виконання 
------------

Метою даної лабораторної роботи було написати простий модуль ядра, який:

  * містить глобальну змінну
  * запускає М потоків на одночасне виконання
  * кожний потік інкрементує змінну N разів та кладе значення змінної в список та завершується
  * при вигрузці, модуль виводить значення змінної та вміст списку
  * використати параметри модулю для задання інкременту N та кількості потоків M
  * для змінної, списку, потоків використати динамічну аллокацію 
  * змінну передавати в потік по ссилці аргументом
  * реалізувати функції ``lock()`` та ``unlock()`` з використанням атомарних операцій ядра
  * враховувати та правильно відпрацьовувати можливі помилки

2. Теоретичні відомості
-----------------------

2.1. Потоки
"""""""""""

Багатопоточність - це популярна сьогодні програмна абстракція. Вона забезпечує виконання декількох потоків в в спільно 
використовуваному адресному просторі пам'яті. Потоки також можуть спільно використовувати відкриті файли і інші ресурси. 
Багатопоточність використовується для паралельного програмування - **concurrent programming**, що на багатопроцесорних системах 
забезпечує істинний паралелізм. Для ядра Linux не існує окремої концепції потоків. У ядрі Linux потоки реалізовані так само, як 
і звичайні процеси. Поток - це просто процес, який використовує деякі ресурси спільно з іншими процесами. Кожен потік має 
структуру і представляється для ядра звичайним процесом (який спільно використовує ресурси, такі як адресний простір, з іншими 
процесами).

2.2. Списки
"""""""""""

На даний момент в ядрі Linux використовується циклічний двозв'язний список. Розглянемо переваги використання таких списків:

  * Незалежність від типу. Можна використовувати будь-яку структуру даних, яку заманеться.
  * Переносимість. 
  * Простота використання. В силу незалежності списків від типу даних записів для ініціалізації, доступу до елементів списку, для проходження за списком використовуються одні й ті ж функції.
  * Простота сприйняття. Макроси та **inline**-функції роблять код дуже елегантним і простим для розуміння.
  * Економія часу. Використання списків дозволяє істотно заощадити час на налагодження і повторне створення списків для кожної структури даних, яка використовується в програмі.

2.3. Атомарні операції
""""""""""""""""""""""

Атомарні операції - **atomic operations** надають інструкції, які виконуються атомарно, - тобто не перериваючись. Так само як і 
атом спочатку вважався неподільною часткою, атомарні операції є неподільними інструкціями. 
Ядро надає два набори інтерфейсів для виконання атомарних операцій: один - для роботи з цілими числами, а інший - для роботи з 
окремими бітами. Ці інтерфейси реалізовані для всіх апаратних платформ, які підтримуються операційною системою Linux. Більшість 
апаратних платформ підтримують атомарні операції або безпосередньо, або шляхом блокування шини доступу до пам'яті при виконанні 
однієї операції (що в свою чергу гарантує, що інша операція не може виконатися паралельно).

3. Результат
------------

Модуль був скомпільований та завантажений на обох архітектурах. 

Результат роботи на архітектурі **x86** наведено на рисунку нижче:

	.. image:: img/pic.jpg

4. Висновок
-----------

to be continued...
""""""""""""""""""
