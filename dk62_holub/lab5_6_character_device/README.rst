=============================================
Лабораторная работа №5-6: Символьное устройство   
=============================================

Структура директории (Directory structure)
-----

+-------------------+----------------------------------+ 
| Folder and files  | description                      |
+===================+==================================+ 
|        scr        | The source code of the lab work  |
+-------------------+----------------------------------+ 
|       Makefile    | File to compile project          | 
+-------------------+----------------------------------+ 
|       README.rst  | Lab work report                  |
+-------------------+----------------------------------+


Цели и задание
-----
Изученение механизма работы символьных устройств.   

- модифицировать исходный пример:
  - добавить инициализацию памяти устроства нулевыми символами
  - добавить механизмы чтения и записи устройства  
  - добавить возможность добавление устройства в ``/dev``  
  - добавить операции с ``ioctl``, которые добавляют в буфер "магическую" строку и позволяют задавать размер буфера 



Теоретическая база работы 
-----

Символьное устройство - это такое устройств, к которому можно обращаться как к потоку байтов (так же как к файлу).
драйвер символьного устройства отвечает за реализацию такого поведения. Такой драйвер обычно, как минимум, 
поддерживает системные вызовы ``open``, ``close``, ``read`` и ``write``. 

Символьные устройства, которые часто обозначают как ``cdevs``, в отличии от блочных устройств, 
обычно не позволяют адресовать отдельные блоки данных. 
Они предоставляют доступ к данным только в виде непрерывного потока символов (байтов). В качестве примеров символьных 
устройств можно привести клавиатуру или мышь. Для доступа к символьным 
устройствам используется специальный файл, называемый узлом символьного устройства (``character device node``). 
В отличие от блочного устройства приложение взаимодействует с символьным устройством напрямую через узел этого устройства.
Несмотря на используемый в системах Unix подход к проектированию, 
заключающийся в том, что “все в системе является файлом”, сетевые устройства ему не подчиняются. Обращение к ним выполняется
не через соответствующий узел файловой системы, а через специальный интерфейс, называемый API-сокетом (socket API). 
В системе Linux используются также и другие типы устройств, но они не являются универсальными и относятся только к одной 
специализированной задаче. Исключением здесь являются смешанные устройства (miscellaneous devices), которые часто обозначают 
как miscdevs. По сути, они являются упрощенной формой символьных устройств. Смешанные устройства позволяют авторам драйверов
с легкостью работать с простыми устройствами и сосредоточить всю функциональность на общей инфраструктуре. 
Однако не все драйверы устройств в системе Linux работают с физическими устройствами. Часть драйверов устройств являются 
виртуальными и обеспечивают доступ к функциональным возможностям ядра. 

Для хранения номеров устройств, обоих, старшего и младшего, в ядре используется тип ``dev_t``. 
Начиная с версии ядра 2.6.0, dev_t является 32-х разрядным, 12 бит отведены для старшего номера и 20 - для младшего.
Для получения старшей или младшей части ``dev_t`` можно использовать:

   .. code-block:: C
   
    MAJOR(dev_t dev); 
    MINOR(dev_t dev);
    
Или же при наличии старшего и младшего номера устройств для преобразования в ``dev_t``:
  
  .. code-block:: C
  
    MKDEV(int major, int minor);

Одним из первых шагов, который необходимо сделать драйверу символьного устройства, 
является получение одного или нескольких номеров устройств для работы с ними. Необходимой функцией для выполнения 
этой задачи является ``register_chrdev_region``, которая объявлена в ``<linux/fs.h>``: 

    .. code-block:: C
    
        int register_chrdev_region(dev_t first, unsigned int count, char *name);

Однако, иногда нету возможности знать, какие старшие номера устройств будут использоваться. 
Ядро может выделить старший номер самостоятельно, для этого используется другая функция: 

    .. code-block:: C
    
        int alloc_chrdev_region(dev_t *dev, unsigned int firstminor, unsigned int count, char *name);

Структура ``file_operations`` определяет операции для работы с драйвером.
Структура определена в ``<linux/fs.h>``, которая состоит из перечня указателей на функции. 
Операции в основном отвечают за осуществление системных вызовов и, таким образом, названы ``open``, 
``read`` и т.д. 
По сути пишется обработчик внутри драйвера, который ассоциируется с определенным системным вызовом. Указатели на 
эти функции обработчик и вмещает в себя структура ``file_operations``.

Выполнение  
-----
В директории ``src`` данной лабораторной работы находится исходный файл драйвера символьного устройства ядра ``hivemod.c`` 
с результатом выполнения заданий в рамках данной работы. Также имеется тест операций чтения и записи.
Проведём небольшой анализ исходного кода:

#. Ниже наведена реализация функции обработчика системного вызова ``write``. Обеспечена защита от записи за пределом выделеного
   места. Копирование данных из пространства пользователя обеспечивается методом ядра ``copy_from_user``, который возвращает нулевое 
   значение в случае успешного выполнения. Таким образом переменная ``retval`` при успешном выполнении должна равняться длине данных ``count``.
   
   
   .. code-block:: C

        static ssize_t cdev_write(struct file *file, const char __user *buf,
			    size_t count, loff_t *loff)
        {
          struct hive_flist_item *item = hive_flist_get(file);
          if (NULL == item)
            return -EBADF;

          //Completed: Add buffer write logic.
          ssize_t retval = -ENOMEM;

          if((count + *loff) > item->length) {
            MOD_DEBUG(KERN_DEBUG, "Attempt to write beyond the dev size!");
            goto EXIT;
          }

          /* copy to user and update the offset in the device */
          retval = count - copy_from_user((item->buffer + *loff), buf, count);
          *loff += retval;

          MOD_DEBUG(KERN_DEBUG, " bytes written: %d, position: %d",\
               (int)retval, (int)*loff);

        EXIT:
          return retval;
        }


#. Аналогичным принципом реализована функция обработчик чтения по системному вызову. Обеспечена защита от чтения за пределом 
   буфера, в таком случае происходит чтение только в доступной части буфера. Для чтения данных в пространство пользователя использован 
   метод ядра ``copy_to_user``, обратный по принципу к ``copy_from_user``.
      
      .. code-block:: C
     
        static ssize_t cdev_read(struct file *file, char __user *buf, 
			 size_t count, loff_t *loff)
        {
          struct hive_flist_item *item = hive_flist_get(file);
          if (NULL == item)
            return -EBADF;
          // Completed: Add buffer read logic.

          ssize_t retval = 0;

          if(*loff > item->length)		
            goto EXIT;
          if((count + *loff) > item->length) {
            MOD_DEBUG(KERN_DEBUG, "Attempt to READ beyond the dev size!");
            
            count = item->length - *loff;
          }

          /* copy to user and update the offset in the device */
          retval = count - copy_to_user(buf, (item->buffer + *loff), count);
          *loff += retval;

          MOD_DEBUG(KERN_DEBUG, " bytes read: %d, position: %d",\
              (int)retval, (int)*loff);
        EXIT:
          return retval;	

          return 0;
        }

#. Само обьявление и определение функции потоков наведено ниже:        
   
    .. code-block:: C
    
          static int thread_func(void *argument)
          {
            lock(local_mutex);
            int i;

              if (N > 0) {
                  for (i = 1; i <= N; i++)
                    (*(int *)argument)++;
              }

            data = kmalloc(sizeof(struct k_list), GFP_KERNEL);

            if(!data){

              printk(KERN_ERR "Allocation error (data)");
              goto errn;	

            }

            data->count_val = *(int *)argument;
            data->thread_cnt = (*(int *)argument)/N;

            list_add(&data->test_list, &head_list);
            unlock(local_mutex);

            return 0;
            errn:
                kfree(data);
                return -ENOMEM;
          }

#. Для обеспечения базовой функциональности чтения-записи устройства, добавлена функция обработчик системного вызова 
   ``lseek``. Реализация самая базовая, которая обеспечивает установку смещения в файле. В дальнейшем функция будет дополнена.
   
    .. code-block:: C
   
      static loff_t cdev_lseek(struct file *file, loff_t f_offset, int action)
      {
        loff_t new_offset;
        struct hive_flist_item *item = hive_flist_get(file);
        if (NULL == item)
          return -EBADF;

        switch (action)
        {
          case SEEK_SET:
            new_offset = f_offset;
            break;

          default:
            new_offset = -EINVAL;
            goto EXIT;
        }

        file->f_pos = new_offset;

        MOD_DEBUG(KERN_DEBUG, "Seeking to position: %ld", (long)new_offset);
      EXIT:
        return new_offset;
      }

#. Для отображения устройства в директории /dev используется следующий код, который наведен ниже. 
   Для начала нужно создать класс устройства. Класс является высокоуровневым представлением устройство.
   В дальнейшем нужно создать устройство и зарегестрировать его в ``sysfs`` с помощью ``device_create``.
   
    .. code-block:: C
        if ((hive_class = class_create(THIS_MODULE, "hive_class")) == NULL) {
            unregister_chrdev_region(hive_dev, 1);
            return -1;
        }
        if (device_create(hive_class, NULL, hive_dev, NULL, "hive_dev") == NULL) {
          class_destroy(hive_class);
          unregister_chrdev_region(hive_dev, 1);
          return -1;
        }    
 
          
Сборка модуля и тестирование 
-----          
Процесс сборки и запуска проекта следующий:

#. Для автоматизированной сборки используется Kbuild. С помощью команды ``make`` производиться сборка и компиляция 
   модуля и тестового кода. Для кросс-компиляции можно также указать архитектуру, компилятор и директорию исходников.  
   Например, компиляции для ARMv7 для SoC ``Zynq-7000``: ``make ARCH=arm CROSS_COMPILE=arm-xilinx-linux-gnueabihf- KBUILDDIR=<path_to_linux_src>/linux-xlnx-xilinx-v2017.4/``.
#. Автоматически при использовании ``make`` проводиться как и загрузка модуля, так его тестирование, выводиться лог ядра.
#. Для удаления резульатов сборки можно использовать ``make clean`` и ``make tidy``.

Анализ полученных результатов 
-----   
Было проведено тестирование операция чтения и записи из(в) пространство пользователя. Ниже приведен результат работы тестовой 
программы в пространстве пользователя и лог ядра с результатами работы символьного устройства.

.. code-block:: C

    Opened fd of hive_dev = 3
    Return from write callback, offset=20, message=TWERK!TWERK!TWERK!

    Return from read callback, offset=20, message=TWERK!TWERK!TWERK!

    [12752.243542] hivemod: Static dev 243:0 created
    [12752.243544] hivemod: This hive has 7 bees
    [12753.249172] hivemod: New file entry 0000000034bba9bb created
    [12753.249568] hivemod: hive: bytes written: 20, position: 20

    [12753.249925] /dev/hive_dev: device: Seeking to position: 0
    [12753.249931] hivemod: hive: device: bytes read: 20, position: 20

    [12753.250186] hivemod: File entry 0000000034bba9bb unlinked
    [12753.252563] hivemod: All honey reclaimed
    

Как можно увидеть, в начале видна отработка тестовой программы, которая пытается сначала записать строку с помощью системного вызова ``write``.
Затем с помощью ``lseek``, выставляется указатель положения в файле на начало и происходит считывание с помощью вызова ``read``. Код успешно вывел записаное 
ранее сообщение. В логах ядра видны отладочные записи в лог про отработку обработчиков каждого системного вызова из пространства пользователя.
